<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>AIDE-QC</title><link>https://aide-qc.github.io/deploy/</link><description>Recent content on AIDE-QC</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 19 Oct 2017 15:26:15 +0000</lastBuildDate><atom:link href="https://aide-qc.github.io/deploy/index.xml" rel="self" type="application/rss+xml"/><item><title>Frequently Asked Questions</title><link>https://aide-qc.github.io/deploy/getting_started/Faq/</link><pubDate>Fri, 29 Nov 2019 00:00:00 +0000</pubDate><guid>https://aide-qc.github.io/deploy/getting_started/Faq/</guid><description>First AIDE-QC FAQ :)</description></item><item><title>Add a New Circuit Synthesis Strategy</title><link>https://aide-qc.github.io/deploy/developers/implement_circuit_synthesis/</link><pubDate>Fri, 29 Nov 2019 15:26:15 +0000</pubDate><guid>https://aide-qc.github.io/deploy/developers/implement_circuit_synthesis/</guid><description>Here we describe how developers can extend the AIDE-QC stack with support for a new circuit synthesis strategy. We define circuit synthesis at the black-box level: a unitary matrix goes in and a list of one and two qubit gates come out.
Background To understand the class architecture for circuit synthesis strategies, it is important to understand the internal intermediate representation that AIDE-QC leverages for compiled quantum kernels. AIDE-QC builds upon the XACC intermediate representation, which exposes Instruction and CompositeInstruction abstract classes that are intended for subclassing for concrete instruction types and collections of concrete instructions.</description></item><item><title>Add a New Optimizer</title><link>https://aide-qc.github.io/deploy/developers/implement_optimizer/</link><pubDate>Fri, 29 Nov 2019 15:26:15 +0000</pubDate><guid>https://aide-qc.github.io/deploy/developers/implement_optimizer/</guid><description>Table of Contents Background Create a Custom L-BFGS Optimizer Test the Custom L-BFGS Optimizer Custom Optimizer Options Background The AIDE-QC software stack provides an extension point for classical, multi-variate function optimization. This provides the means to experiment with multiple optimization strategies pertinent to variational quantum computing algorithms (e.g. VQE).
We describe optimization via an extensible Optimizer class. The essential structure of the Optimizer infrastructure is shown below</description></item><item><title>Add a New QSim Workflow</title><link>https://aide-qc.github.io/deploy/developers/implement_qsim_workflow/</link><pubDate>Fri, 29 Nov 2019 15:26:15 +0000</pubDate><guid>https://aide-qc.github.io/deploy/developers/implement_qsim_workflow/</guid><description>QSim is a domain-specific library for quantum simulation in the AIDE-QC software stack. The key extension point of QSim is its QuantumSimulationWorkflow interface, which is essentially the simulation driver for different protocols/procedures. Please refer to this page for more information about QSim and its components.
Besides its built-in workflow implementations (e.g. vqe, qaoa, etc.), users/developers may want to implement a new workflow (as a plugin) and contribute to the AIDE-QC stack.</description></item><item><title>Add a New Quantum Backend</title><link>https://aide-qc.github.io/deploy/developers/implement_accelerator/</link><pubDate>Fri, 29 Nov 2019 15:26:15 +0000</pubDate><guid>https://aide-qc.github.io/deploy/developers/implement_accelerator/</guid><description>Here we detail how one might inject a new simulator or physical backend into the AIDE-QC software stack. The process for doing this is via the implementation of a new xacc::Accelerator sub-class, and its contribution to the stack as a new plugin library.
Background class Accelerator : public Identifiable { public: virtual void initialize(const HeterogeneousMap &amp;amp;params = {}) = 0; virtual void updateConfiguration(const HeterogeneousMap &amp;amp;config) = 0; virtual const std::vector&amp;lt;std::string&amp;gt; configurationKeys() = 0; virtual HeterogeneousMap getProperties(); virtual std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt;&amp;gt; getConnectivity(); // Execute a single program.</description></item><item><title>Build Everything from Source</title><link>https://aide-qc.github.io/deploy/getting_started/build_from_source/</link><pubDate>Fri, 29 Nov 2019 15:26:15 +0000</pubDate><guid>https://aide-qc.github.io/deploy/getting_started/build_from_source/</guid><description>Table of Contents Install Dependencies XACC and QCOR on Ubuntu XACC and QCOR on Mac OS X and Linux x86_64 with Homebrew Build the LLVM Clang SyntaxHandler Fork For the adventurous out there, or if your system does not support the above prebuilt binary instructions, you can build the AIDE-QC components from source.
Install Dependencies Run the package installer commands for your system to get all requisite dependencies:</description></item><item><title>Hello World</title><link>https://aide-qc.github.io/deploy/users/hello_world/</link><pubDate>Fri, 29 Nov 2019 15:26:15 +0000</pubDate><guid>https://aide-qc.github.io/deploy/users/hello_world/</guid><description>The AIDE-QC software stack promotes a hardware-agnostic, single-source programming model for efficient and extensible heterogeneous quantum-classical computing. Here we want to provide a small hello world example that attempts to demonstrate that model. Specifically, we will show how to program a simple GHZ state quantum kernel that can run on any of the available QPUs that are integrated with the AIDE-QC stack.
Let&amp;rsquo;s start of in C++. We start by describing a quantum kernel - a C++ function, annotated with __qpu__ whose function body contains some quantum code.</description></item><item><title>Hybrid C++ / Python Plugins</title><link>https://aide-qc.github.io/deploy/developers/implement_plugin_embedded_python/</link><pubDate>Fri, 29 Nov 2019 15:26:15 +0000</pubDate><guid>https://aide-qc.github.io/deploy/developers/implement_plugin_embedded_python/</guid><description>Background In this article, we will demonstrate how one might integrate python code as a new plugin with the C++ AIDE-QC stack, thereby making it available for use with the C++ and Python AIDE-QC API. We have shown this in a cursory way in the Add a New Quantum Backend article. Here we devote a bit more time to the pybind11 bindings, and the requirements for ensuring a working plugin for use in C++ and Python.</description></item><item><title>Operators</title><link>https://aide-qc.github.io/deploy/users/operators/</link><pubDate>Fri, 29 Nov 2019 15:26:15 +0000</pubDate><guid>https://aide-qc.github.io/deploy/users/operators/</guid><description>The AIDE-QC stack puts forward as part of the QCOR specification an extensible model for quantum mechanical operators.
We sub-type this concept for operators exposing a certain algebra. We have defined PauliOperator and FermionOperator sub-types, and have put forward a mechanism for transformation between the two.
Spin Operators AIDE-QC puts forward an Operator implementation to model Pauli matrices, Pauli tensor products, and sums of Pauli tensor products. The PauliOperator can be create in C++ and Python and used in the familiar algebraic name.</description></item><item><title>Pass Manager</title><link>https://aide-qc.github.io/deploy/users/pass_manager/</link><pubDate>Fri, 29 Nov 2019 15:26:15 +0000</pubDate><guid>https://aide-qc.github.io/deploy/users/pass_manager/</guid><description>The QCOR infrastructure has a wide variety of quantum circuit transformation plugins, which are often referred to as transpilers in the literature.
There are two categories of transpilers: circuit optimization and placement.
Circuit optimizers are plugins that can rewrite the input circuits into a more optimal form (fewer gates) while reserving the intended transformation (e.g. in terms of the overall unitary matrix).
Placement plugins act as the final router to map or embed the circuit into the backend hardware topology.</description></item><item><title>QCOR C++ Compiler and JIT Engine</title><link>https://aide-qc.github.io/deploy/background/qcor/</link><pubDate>Fri, 29 Nov 2019 15:26:15 +0000</pubDate><guid>https://aide-qc.github.io/deploy/background/qcor/</guid><description/></item><item><title>Quantum JIT (QJIT)</title><link>https://aide-qc.github.io/deploy/users/qjit/</link><pubDate>Fri, 29 Nov 2019 15:26:15 +0000</pubDate><guid>https://aide-qc.github.io/deploy/users/qjit/</guid><description>The quantum kernel programming model in C++ for the AIDE-QC stack relies on a novel Clang plugin interface called the SyntaxHandler . This infrastructure enables quantum programming with annotated C++ functions in a language agnostic manner. A downside to this is that quantum kernels are defined at compile-time and are therefore less-flexible for use cases where runtime-generated circuits are useful.
To address this, we have put forward an infrastructure for just-in-time compilation of quantum kernels.</description></item><item><title>Quantum Kernels</title><link>https://aide-qc.github.io/deploy/users/quantum_kernels/</link><pubDate>Fri, 29 Nov 2019 15:26:15 +0000</pubDate><guid>https://aide-qc.github.io/deploy/users/quantum_kernels/</guid><description>The AIDE-QC stack programming model treats available QPUs (physical or virtual) as general co-processors. Programming those co-processors consists of defining what we call quantum kernels - standard functions (in the classical language) whose function body is made up of some quantum domain specific language (DSL), and the function is annotated appropriately to indicate that this function is quantum. These domain specific languages can be low-level quantum assembly representations, or high-level language constructs that the qcor compiler can parse and compile to appropriate instructions for the targeted backend.</description></item><item><title>Quantum Simulation (QSim)</title><link>https://aide-qc.github.io/deploy/users/qsim/</link><pubDate>Fri, 29 Nov 2019 15:26:15 +0000</pubDate><guid>https://aide-qc.github.io/deploy/users/qsim/</guid><description>Table of Contents Overview Simulation Model Workflow Cost Function Evaluate Implement a new workflow Overview The QSim library provides domain-specific tools for quantum simulation on quantum computers. It supports problems such as ground-state energy computations or time-dependent simulations.
The library comprises the main drivers, so-called workflows (QuantumSimulationWorkflow), which encapsulate the procedure (classical and quantum routines) to solve the quantum simulation problem.</description></item><item><title>Remote QPU Credentials</title><link>https://aide-qc.github.io/deploy/users/remote_qpu_creds/</link><pubDate>Fri, 29 Nov 2019 15:26:15 +0000</pubDate><guid>https://aide-qc.github.io/deploy/users/remote_qpu_creds/</guid><description>qcor provides a set of command line arguments that make it simple to set your remote QPU API credentials.
IBM API Credentials To execute quantum kernels on the remote IBM backends, run the following
qcor -set-credentials ibm -key YOURKEY -hub YOURHUB -group YOURGROUP -project YOURPROJECT where YOURKEY, YOURHUB, YOURGROUP, and YOURPROJECT are provided by your account with the IBM Quantum ecosystem.
To view your currently set API credentials
qcor -print-credentials ibm To update any aspect of your credentials (could do this for project, group, key, hub)</description></item><item><title>Tensor Network Quantum Virtual Machine</title><link>https://aide-qc.github.io/deploy/users/tnqvm/</link><pubDate>Fri, 29 Nov 2019 15:26:15 +0000</pubDate><guid>https://aide-qc.github.io/deploy/users/tnqvm/</guid><description>TNQVM is an Accelerator implementation that leverages tensor network theory to simulate quantum circuits.
TNQVM supports ITensor -MPS (built-in) and ExaTN numerical tensor processing libraries.
Install the TNQVM Required Dependencies: XACC (part of AIDE-QC Software Stack)
Optional Dependencies: ExaTN, MPI
Locate XACC install directory Depending on the way XACC was installed, e.g. compiling from source or using apt-get/brew, XACC may be located at different locations.
For example, if installed from source, XACC can be found at $HOME/.</description></item><item><title>Using an Optimizer</title><link>https://aide-qc.github.io/deploy/users/using_optimizer/</link><pubDate>Fri, 29 Nov 2019 15:26:15 +0000</pubDate><guid>https://aide-qc.github.io/deploy/users/using_optimizer/</guid><description>Optimizers have proven ubiquitous across variational quantum computation. AIDE-QC is focused on the development of novel optimization strategies for noisy quantum co-processors. To deploy these strategies in an extensible and modular way, the AIDE-QC software stack puts forward and Optimizer interface / concept that can be implemented for particular optimization strategies. Currently, we provide a number of implementations, some of which delegate to popular optimization libraries that provide a wealth of gradient-based and derivative free algorithms.</description></item><item><title>Variational Algorithms</title><link>https://aide-qc.github.io/deploy/users/variational/</link><pubDate>Fri, 29 Nov 2019 15:26:15 +0000</pubDate><guid>https://aide-qc.github.io/deploy/users/variational/</guid><description/></item><item><title>XACC Quantum Programming Framework</title><link>https://aide-qc.github.io/deploy/background/xacc/</link><pubDate>Fri, 29 Nov 2019 15:26:15 +0000</pubDate><guid>https://aide-qc.github.io/deploy/background/xacc/</guid><description/></item><item><title/><link>https://aide-qc.github.io/deploy/background/project/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://aide-qc.github.io/deploy/background/project/</guid><description/></item><item><title/><link>https://aide-qc.github.io/deploy/developers/clang_syntax/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://aide-qc.github.io/deploy/developers/clang_syntax/</guid><description/></item></channel></rss>
<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Tensor Network Quantum Virtual Machine - AIDE-QC</title><meta name=description content="Advancing Integrated Development Environments for Quantum Computing"><meta name=generator content="Hugo 0.76.5"><link href=https://aide-qc.github.io/deployindex.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://aide-qc.github.io/deploy/users/tnqvm/><link rel=stylesheet href=https://aide-qc.github.io/deploy/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=https://aide-qc.github.io/deploy/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=https://aide-qc.github.io/deploy/js/bundle.js></script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://aide-qc.github.io/deploy/aide_qc_logo_v3.png width=40px align=absmiddle>
AIDE-QC</div></h1><p class=description>Advancing Integrated Development Environments for Quantum Computing</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://aideqc.slack.com>AIDE-QC Slack</a></li><li class=child><a href=https://xacc-dev.slack.com>XACC/QCOR Slack</a></li></ul></li><li class=parent><a href=https://github.com/aide-qc>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://ornl-qci.github.io/qcor-api-docs/>QCOR Doxygen</a></li><li class=child><a href=https://ornl-qci.github.io/xacc-api-docs/>XACC Doxygen</a></li><li class=child><a href=https://github.com/aide-qc/qcor>QCOR</a></li><li class=child><a href=https://github.com/aide-qc/xacc>XACC</a></li></ul></li><li><a href=https://github.com/aide-qc/aide-qc/issues>Bugs</a></li><li><a href=http://aide-qc.org>Project Page</a></li></ul></nav></div><div class=content-container><main><h1>Tensor Network Quantum Virtual Machine</h1><p><a href=https://github.com/ORNL-QCI/tnqvm>TNQVM</a>
is an <code>Accelerator</code> implementation that leverages tensor network theory to simulate quantum circuits.</p><p>TNQVM supports
<a href=http://itensor.org>ITensor</a>
-MPS (built-in) and
<a href=https://github.com/ORNL-QCI/exatn>ExaTN</a>
numerical tensor processing libraries.</p><h2 id=a-idinstallationa-install-the-tnqvm><a id=installation></a>Install the TNQVM&nbsp;<a class=headline-hash href=#a-idinstallationa-install-the-tnqvm>¶</a></h2><p><strong>Required Dependencies</strong>: XACC (part of AIDE-QC Software Stack)</p><p><strong>Optional Dependencies</strong>: ExaTN, MPI</p><h3 id=locate-xacc-install-directory>Locate XACC install directory&nbsp;<a class=headline-hash href=#locate-xacc-install-directory>¶</a></h3><p>Depending on the way XACC was installed, e.g. compiling from source or using <code>apt-get</code>/<code>brew</code>, XACC may be located at different locations.</p><p>For example, if installed from source, XACC can be found at <code>$HOME/.xacc</code> by default.</p><p>On the other hand, if the AIDE-QC Software Stack was installed with <code>apt-get install qcor</code>, XACC can be found at <code>/usr/local/xacc</code>.</p><p>You can always locate where XACC is installed with</p><div class=highlight><pre class=chroma><code class=language-sh data-lang=sh>qcor -xacc-install
</code></pre></div><h3 id=optional-clone-and-build-exatn-library><em>(Optional)</em> Clone and build ExaTN library&nbsp;<a class=headline-hash href=#optional-clone-and-build-exatn-library>¶</a></h3><p>If ExaTN backends are required, we need to clone and build the ExaTN library before compiling TNQVM.</p><p>Full build instructions can be found
<a href=https://github.com/ORNL-QCI/exatn#linux-build-instructions>here</a>
.
In the followings, we just provides examples for some common build configurations.</p><div class=highlight><pre class=chroma><code class=language-bash data-lang=bash>git clone https://github.com/ORNL-QCI/exatn.git
<span class=nb>cd</span> exatn <span class=o>&amp;&amp;</span> mkdir build <span class=o>&amp;&amp;</span> <span class=nb>cd</span> build
cmake .. -DBLAS_LIB<span class=o>=</span>&lt;BLAS_LIB_NAME&gt; -DBLAS_PATH<span class=o>=</span>&lt;BLAS_LIB_PATH&gt; -DMPI_LIB<span class=o>=</span>&lt;MPI_LIB_NAME&gt; -DMPI_ROOT_DIR<span class=o>=</span>&lt;MPI_LIB_PATH&gt; -DMPI_BIN_PATH<span class=o>=</span>&lt;MPI_BIN_PATH&gt;
make install
</code></pre></div><table><thead><tr><th>Variable</th><th>Description</th><th>Example</th></tr></thead><tbody><tr><td>&lt;BLAS_LIB_NAME></td><td>Name of the Blas library</td><td><code>ATLAS</code></td></tr><tr><td>&lt;BLAS_LIB_PATH></td><td>Path to the Blas library</td><td><code>/usr/lib/x86_64-linux-gnu</code></td></tr><tr><td>&lt;MPI_LIB_NAME></td><td>Name of the MPI implementation</td><td><code>MPICH</code> or <code>OPENMPI</code></td></tr><tr><td>&lt;MPI_LIB_PATH></td><td>Path to the MPI library</td><td><code>/usr/lib/x86_64-linux-gnu/openmpi/</code></td></tr><tr><td>&lt;MPI_BIN_PATH></td><td>Path to the directory that contains MPI binary executables, e.g. <code>mpirun</code>.</td><td><code>/usr/bin</code></td></tr></tbody></table><p><strong>Note:</strong> if you need to use ExaTN with GPU hardware (e.g. CUDA), please follow the instructions
<a href=https://github.com/ORNL-QCI/exatn#linux-build-instructions>here</a>
.</p><p>After installation, ExaTN will be located at <code>$HOME/.exatn</code> by default unless a specific <code>CMAKE_INSTALL_PREFIX</code> value was specified. We will need this information to compile TNQVM with ExaTN in the next step.</p><h3 id=clone-and-build-tnqvm>Clone and build TNQVM&nbsp;<a class=headline-hash href=#clone-and-build-tnqvm>¶</a></h3><h4 id=without-exatn>Without ExaTN:&nbsp;<a class=headline-hash href=#without-exatn>¶</a></h4><p>If we only want to use TNQVM with the built-in ITensor-MPS numerical backend (skipping the above step), the build instructions are:</p><div class=highlight><pre class=chroma><code class=language-bash data-lang=bash>git clone  https://github.com/ornl-qci/tnqvm 
<span class=nb>cd</span> tnqvm <span class=o>&amp;&amp;</span> mkdir build <span class=o>&amp;&amp;</span> <span class=nb>cd</span> build 
cmake .. -DXACC_DIR<span class=o>=</span>&lt;XACC_DIR&gt; -DTNQVM_BUILD_TESTS<span class=o>=</span>TRUE
make install
</code></pre></div><p><code>&lt;XACC_DIR></code> is the XACC install directory that we have located in the first
<a href=#locate-xacc-install-directory>step</a>
, e.g. <code>$HOME/.xacc</code> if installed from source or <code>/usr/local/xacc</code> if using <code>apt-get</code>.</p><p><code>-DTNQVM_BUILD_TESTS=TRUE</code> is optional but <em>highly-recommended</em> to validate the TNQVM installation.
If set, we can test the installation by running the <code>ctest</code> command after <code>make install</code>.</p><h4 id=with-exatn>With ExaTN:&nbsp;<a class=headline-hash href=#with-exatn>¶</a></h4><div class=highlight><pre class=chroma><code class=language-bash data-lang=bash>git clone  https://github.com/ornl-qci/tnqvm 
<span class=nb>cd</span> tnqvm <span class=o>&amp;&amp;</span> mkdir build <span class=o>&amp;&amp;</span> <span class=nb>cd</span> build 
cmake .. -DXACC_DIR<span class=o>=</span>&lt;XACC_DIR&gt; -DEXATN_DIR<span class=o>=</span>&lt;EXATN_DIR&gt; -DTNQVM_BUILD_TESTS<span class=o>=</span>TRUE
make install
</code></pre></div><p><code>&lt;EXATN_DIR></code> is the location of the ExaTN library, which was installed in the previous step. As before, it is highly-recommended that we test the installation afterward by running <code>ctest</code>.</p><h4 id=enable-multi-node-mps-tensor-distribution>Enable multi-node MPS Tensor distribution&nbsp;<a class=headline-hash href=#enable-multi-node-mps-tensor-distribution>¶</a></h4><p>When using <strong>with</strong> ExaTN, TNQVM can support MPS tensors that are distributed across multi nodes. This feature can be enabled by adding <code>-DTNQVM_MPI_ENABLED=TRUE</code> to CMake along with other configuration variables.</p><p><strong>Prerequisites</strong>: ExaTN is built with MPI enabled, i.e., setting <code>MPI_LIB</code> and <code>MPI_ROOT_DIR</code> when configuring the ExaTN build.</p><p>Build configurations:</p><div class=highlight><pre class=chroma><code class=language-bash data-lang=bash>git clone  https://github.com/ornl-qci/tnqvm 
<span class=nb>cd</span> tnqvm <span class=o>&amp;&amp;</span> mkdir build <span class=o>&amp;&amp;</span> <span class=nb>cd</span> build 
cmake .. -DXACC_DIR<span class=o>=</span>&lt;XACC_DIR&gt; -DEXATN_DIR<span class=o>=</span>&lt;EXATN_DIR&gt; -DTNQVM_BUILD_TESTS<span class=o>=</span>TRUE -DTNQVM_MPI_ENABLED<span class=o>=</span>TRUE
make install
</code></pre></div><h2 id=a-idusagea-using-tnqvm><a id=usage></a>Using TNQVM&nbsp;<a class=headline-hash href=#a-idusagea-using-tnqvm>¶</a></h2><p>The TNQVM Accelerator can be requested in the XACC framework by</p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=k>auto</span> <span class=n>qpu</span> <span class=o>=</span> <span class=n>xacc</span><span class=o>::</span><span class=n>getAccelerator</span><span class=p>(</span><span class=s>&#34;tnqvm&#34;</span><span class=p>,</span> <span class=p>{{</span><span class=s>&#34;tnqvm-visitor&#34;</span><span class=p>,</span> <span class=s>&#34;exatn&#34;</span><span class=p>}});</span>
</code></pre></div><p>The <code>tnqvm-visitor</code> key can refer to one of the following options:</p><table><thead><tr><th><code>tnqvm-visitor</code></th><th>Description</th></tr></thead><tbody><tr><td><code>itensor-mps</code></td><td>MPS simulator based on itensor library.</td></tr><tr><td><code>exatn</code></td><td>Full tensor contraction simulator based on ExaTN library.</td></tr><tr><td><code>exatn-mps</code></td><td>MPS simulator based on ExaTN library.</td></tr><tr><td><code>exatn-pmps</code></td><td>Purified-MPS (density matrix) simulator based on ExaTN library.</td></tr></tbody></table><p><strong>Note</strong>: If TNQVM was built without ExaTN, only the <code>itensor-mps</code> visitor will be available.</p><h3 id=full-tensor-contraction-simulation>Full tensor contraction simulation&nbsp;<a class=headline-hash href=#full-tensor-contraction-simulation>¶</a></h3><p>Let&rsquo;s look at a typical Bell-state quantum circuit simulation:</p><table><tr><th>Bell Experiment - C++</th><th>Bell Experiment - Python</th></tr><tr><td><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=cp>#include</span> <span class=cpf>&#34;xacc.hpp&#34;</span><span class=cp>
</span><span class=cp></span><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>**</span><span class=n>argv</span><span class=p>)</span> <span class=p>{</span>
  <span class=n>xacc</span><span class=o>::</span><span class=n>Initialize</span><span class=p>(</span><span class=n>argc</span><span class=p>,</span> <span class=n>argv</span><span class=p>);</span>
  <span class=c1>// Get reference to the TNQVM Accelerator
</span><span class=c1></span>  <span class=k>auto</span> <span class=n>accelerator</span> <span class=o>=</span> <span class=n>xacc</span><span class=o>::</span><span class=n>getAccelerator</span><span class=p>(</span>
      <span class=s>&#34;tnqvm&#34;</span><span class=p>,</span> <span class=p>{{</span><span class=s>&#34;tnqvm-visitor&#34;</span><span class=p>,</span> <span class=s>&#34;exatn&#34;</span><span class=p>},</span> <span class=p>{</span><span class=s>&#34;shots&#34;</span><span class=p>,</span> <span class=mi>1024</span><span class=p>}});</span>

  <span class=c1>// Allocate some qubits
</span><span class=c1></span>  <span class=k>auto</span> <span class=n>buffer</span> <span class=o>=</span> <span class=n>xacc</span><span class=o>::</span><span class=n>qalloc</span><span class=p>(</span><span class=mi>2</span><span class=p>);</span>
  <span class=k>auto</span> <span class=n>xasmCompiler</span> <span class=o>=</span> <span class=n>xacc</span><span class=o>::</span><span class=n>getCompiler</span><span class=p>(</span><span class=s>&#34;xasm&#34;</span><span class=p>);</span>
  <span class=k>auto</span> <span class=n>ir</span> <span class=o>=</span> <span class=n>xasmCompiler</span><span class=o>-&gt;</span><span class=n>compile</span><span class=p>(</span><span class=n>R</span><span class=s>&#34;(__qpu__ void bell(qbit q) {</span>
      <span class=n>H</span><span class=p>(</span><span class=n>q</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span>
      <span class=n>CX</span><span class=p>(</span><span class=n>q</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>q</span><span class=p>[</span><span class=mi>1</span><span class=p>]);</span>
      <span class=n>Measure</span><span class=p>(</span><span class=n>q</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span>
      <span class=n>Measure</span><span class=p>(</span><span class=n>q</span><span class=p>[</span><span class=mi>1</span><span class=p>]);</span>
  <span class=p>})</span><span class=s>&#34;, accelerator);</span>

  <span class=n>accelerator</span><span class=o>-&gt;</span><span class=n>execute</span><span class=p>(</span><span class=n>buffer</span><span class=p>,</span> <span class=n>ir</span><span class=o>-&gt;</span><span class=n>getComposites</span><span class=p>()[</span><span class=mi>0</span><span class=p>]);</span>
  <span class=n>buffer</span><span class=o>-&gt;</span><span class=n>print</span><span class=p>();</span>
  <span class=n>xacc</span><span class=o>::</span><span class=n>Finalize</span><span class=p>();</span>
  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div></td><td><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=kn>import</span> <span class=nn>xacc</span>
<span class=n>qpu</span> <span class=o>=</span> <span class=n>xacc</span><span class=o>.</span><span class=n>getAccelerator</span><span class=p>(</span><span class=s1>&#39;tnqvm&#39;</span><span class=p>,</span> <span class=p>{</span> <span class=s1>&#39;tnqvm-visitor&#39;</span><span class=p>:</span> <span class=s1>&#39;exatn&#39;</span><span class=p>,</span> <span class=s1>&#39;shots&#39;</span><span class=p>:</span> <span class=mi>1024</span> <span class=p>})</span>

<span class=c1># Define the quantum kernel in standard Python</span>
<span class=nd>@xacc.qpu</span><span class=p>(</span><span class=n>accelerator</span><span class=o>=</span><span class=n>qpu</span><span class=p>)</span>
<span class=k>def</span> <span class=nf>bell</span><span class=p>(</span><span class=n>q</span><span class=p>):</span>
    <span class=n>H</span><span class=p>(</span><span class=n>q</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span>
    <span class=n>CX</span><span class=p>(</span><span class=n>q</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span><span class=n>q</span><span class=p>[</span><span class=mi>1</span><span class=p>])</span>
    <span class=n>Measure</span><span class=p>(</span><span class=n>q</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span>
    <span class=n>Measure</span><span class=p>(</span><span class=n>q</span><span class=p>[</span><span class=mi>1</span><span class=p>])</span>

<span class=c1># Allocate 2 qubits</span>
<span class=n>q</span> <span class=o>=</span> <span class=n>xacc</span><span class=o>.</span><span class=n>qalloc</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span>

<span class=c1># run the bell state computation</span>
<span class=n>bell</span><span class=p>(</span><span class=n>q</span><span class=p>)</span>

<span class=k>print</span><span class=p>(</span><span class=n>q</span><span class=p>)</span>
</code></pre></div></td></tr></table><p>Similarly, TNQVM can be used with the QCOR compiler.
Rather than explicitly requesting the TNQVM accelerator, one just need to pass <code>tnqvm</code> to the <code>-qpu</code> command-line argument when compiling with QCOR.</p><table><tr><th>Bell Experiment - C++</th><th>Bell Experiment - Python</th></tr><tr><td>Compile and run with<div class=highlight><pre class=chroma><code class=language-bash data-lang=bash>qcor -qpu tnqvm<span class=o>[</span>tnqvm-visitor:exatn<span class=o>]</span> -shots <span class=m>1024</span> bell.cpp
./a.out
</code></pre></div></td><td><p>Run with</p><div class=highlight><pre class=chroma><code class=language-bash data-lang=bash>python3 bell.py -qpu tnqvm<span class=o>[</span>tnqvm-visitor:exatn<span class=o>]</span> -shots <span class=m>1024</span>
</code></pre></div></td></tr><tr><td><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=n>__qpu__</span> <span class=kt>void</span> <span class=nf>bell</span><span class=p>(</span><span class=n>qreg</span> <span class=n>q</span><span class=p>)</span> <span class=p>{</span>
  <span class=n>H</span><span class=p>(</span><span class=n>q</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span>
  <span class=n>CX</span><span class=p>(</span><span class=n>q</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>q</span><span class=p>[</span><span class=mi>1</span><span class=p>]);</span>
  <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>q</span><span class=p>.</span><span class=n>size</span><span class=p>();</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>Measure</span><span class=p>(</span><span class=n>q</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>
  <span class=p>}</span>
<span class=p>}</span>

<span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
  <span class=k>auto</span> <span class=n>q</span> <span class=o>=</span> <span class=n>qalloc</span><span class=p>(</span><span class=mi>2</span><span class=p>);</span>
  <span class=c1>// Run the quantum kernel
</span><span class=c1></span>  <span class=n>bell</span><span class=p>(</span><span class=n>q</span><span class=p>);</span>
  <span class=n>q</span><span class=p>.</span><span class=n>print</span><span class=p>();</span>
<span class=p>}</span>
</code></pre></div></td><td><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=kn>from</span> <span class=nn>qcor</span> <span class=kn>import</span> <span class=n>qjit</span><span class=p>,</span> <span class=n>qalloc</span><span class=p>,</span> <span class=n>qreg</span>

<span class=c1># Define a Bell kernel</span>
<span class=nd>@qjit</span>
<span class=k>def</span> <span class=nf>bell</span><span class=p>(</span><span class=n>q</span> <span class=p>:</span> <span class=n>qreg</span><span class=p>):</span>
    <span class=n>H</span><span class=p>(</span><span class=n>q</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span>
    <span class=n>CX</span><span class=p>(</span><span class=n>q</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>q</span><span class=p>[</span><span class=mi>1</span><span class=p>])</span>
    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>q</span><span class=o>.</span><span class=n>size</span><span class=p>()):</span>
        <span class=n>Measure</span><span class=p>(</span><span class=n>q</span><span class=p>[</span><span class=n>i</span><span class=p>])</span>

<span class=c1># Allocate 2 qubits</span>
<span class=n>q</span> <span class=o>=</span> <span class=n>qalloc</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span>

<span class=c1># Run the bell experiment</span>
<span class=n>bell</span><span class=p>(</span><span class=n>q</span><span class=p>)</span>

<span class=c1># Print the results</span>
<span class=n>q</span><span class=o>.</span><span class=k>print</span><span class=p>()</span>
</code></pre></div></td></tr></table><h3 id=approximate-simulation-with-mps>Approximate simulation with MPS&nbsp;<a class=headline-hash href=#approximate-simulation-with-mps>¶</a></h3><p>To use the MPS-bases simulator, one needs to pass the name <code>exatn-mps</code> to the <code>tnqvm-visitor</code> option as shown in the below C++ example.</p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=cp>#include</span> <span class=cpf>&#34;xacc.hpp&#34;</span><span class=cp>
</span><span class=cp></span>
<span class=kt>int</span> <span class=nf>main</span> <span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span><span class=o>**</span> <span class=n>argv</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// Initialize the XACC Framework
</span><span class=c1></span>    <span class=n>xacc</span><span class=o>::</span><span class=n>Initialize</span><span class=p>(</span><span class=n>argc</span><span class=p>,</span> <span class=n>argv</span><span class=p>);</span>
    <span class=n>xacc</span><span class=o>::</span><span class=n>set_verbose</span><span class=p>(</span><span class=nb>true</span><span class=p>);</span>
    <span class=k>auto</span> <span class=n>qpu</span> <span class=o>=</span> <span class=n>xacc</span><span class=o>::</span><span class=n>getAccelerator</span><span class=p>(</span><span class=s>&#34;tnqvm&#34;</span><span class=p>,</span> <span class=p>{</span>
        <span class=p>{</span><span class=s>&#34;tnqvm-visitor&#34;</span><span class=p>,</span> <span class=s>&#34;exatn-mps&#34;</span><span class=p>},</span>
        <span class=p>{</span><span class=s>&#34;shots&#34;</span><span class=p>,</span> <span class=mi>10</span><span class=p>},</span>
    <span class=p>});</span>

    <span class=c1>// Allocate a register of 40 qubits
</span><span class=c1></span>    <span class=k>auto</span> <span class=n>qubitReg</span> <span class=o>=</span> <span class=n>xacc</span><span class=o>::</span><span class=n>qalloc</span><span class=p>(</span><span class=mi>40</span><span class=p>);</span>

    <span class=c1>// Create a Program
</span><span class=c1></span>    <span class=k>auto</span> <span class=n>xasmCompiler</span> <span class=o>=</span> <span class=n>xacc</span><span class=o>::</span><span class=n>getCompiler</span><span class=p>(</span><span class=s>&#34;xasm&#34;</span><span class=p>);</span>
    <span class=k>auto</span> <span class=n>ir</span> <span class=o>=</span> <span class=n>xasmCompiler</span><span class=o>-&gt;</span><span class=n>compile</span><span class=p>(</span><span class=n>R</span><span class=s>&#34;(__qpu__ void ghz(qbit q) {</span>
        <span class=n>H</span><span class=p>(</span><span class=n>q</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span>
        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>39</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>CX</span><span class=p>(</span><span class=n>q</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>q</span><span class=p>[</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>]);</span>
        <span class=p>}</span>
        <span class=c1>// Measure two random qubits
</span><span class=c1></span>        <span class=c1>// should only get entangled bitstrings:
</span><span class=c1></span>        <span class=c1>// i.e. 00 or 11
</span><span class=c1></span>        <span class=n>Measure</span><span class=p>(</span><span class=n>q</span><span class=p>[</span><span class=mi>2</span><span class=p>]);</span>
        <span class=n>Measure</span><span class=p>(</span><span class=n>q</span><span class=p>[</span><span class=mi>37</span><span class=p>]);</span>
    <span class=p>})</span><span class=s>&#34;, qpu);</span>

    <span class=c1>// Request the quantum kernel representing
</span><span class=c1></span>    <span class=c1>// the above source code
</span><span class=c1></span>    <span class=k>auto</span> <span class=n>program</span> <span class=o>=</span> <span class=n>ir</span><span class=o>-&gt;</span><span class=n>getComposite</span><span class=p>(</span><span class=s>&#34;ghz&#34;</span><span class=p>);</span>
    <span class=c1>// Execute!
</span><span class=c1></span>    <span class=n>qpu</span><span class=o>-&gt;</span><span class=n>execute</span><span class=p>(</span><span class=n>qubitReg</span><span class=p>,</span> <span class=n>program</span><span class=p>);</span>
    <span class=n>qubitReg</span><span class=o>-&gt;</span><span class=n>print</span><span class=p>();</span>

    <span class=c1>// Finalize the XACC Framework
</span><span class=c1></span>    <span class=n>xacc</span><span class=o>::</span><span class=n>Finalize</span><span class=p>();</span>
    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><p>In this example, we simulate a simple cat-state experiment with a rather large number of qubits (40). Since this is an MPS-based simulator, the amount of memory required depends on the amount of entanglement, which is not much in this case. Hence, we can easily run this simulation on our laptops.</p><h3 id=noisy-simulation-with-locally-purified-mps-simulator>Noisy simulation with locally-purified MPS simulator&nbsp;<a class=headline-hash href=#noisy-simulation-with-locally-purified-mps-simulator>¶</a></h3><p>TNQVM is experimentally supporting noisy circuit simulation using the locally-purified MPS method. The <code>tnqvm-visitor</code> name for this method is <code>exatn-pmps</code>.</p><p>In this mode, users need to either provide the device/backend model in JSON format (using configuration key <code>backend-json</code>) or specify an IBMQ backend that they want to emulate (using the <code>backend</code> option). The latter is demonstrated in the below example.</p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=cp>#include</span> <span class=cpf>&#34;xacc.hpp&#34;</span><span class=cp>
</span><span class=cp></span>
<span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>**</span><span class=n>argv</span><span class=p>)</span> <span class=p>{</span>

  <span class=c1>// Initialize the XACC Framework
</span><span class=c1></span>  <span class=n>xacc</span><span class=o>::</span><span class=n>Initialize</span><span class=p>(</span><span class=n>argc</span><span class=p>,</span> <span class=n>argv</span><span class=p>);</span>

  <span class=c1>// Using the purified-mps backend with noise model from
</span><span class=c1></span>  <span class=c1>// &#34;ibmq_5_yorktown - ibmqx2&#34; device.
</span><span class=c1></span>  <span class=k>auto</span> <span class=n>qpu</span> <span class=o>=</span> <span class=n>xacc</span><span class=o>::</span><span class=n>getAccelerator</span><span class=p>(</span>
      <span class=s>&#34;tnqvm&#34;</span><span class=p>,</span> <span class=p>{{</span><span class=s>&#34;tnqvm-visitor&#34;</span><span class=p>,</span> <span class=s>&#34;exatn-pmps&#34;</span><span class=p>},</span> <span class=p>{</span><span class=s>&#34;backend&#34;</span><span class=p>,</span> <span class=s>&#34;ibmqx2&#34;</span><span class=p>}});</span>

  <span class=c1>// Allocate a register of 2 qubits
</span><span class=c1></span>  <span class=k>auto</span> <span class=n>qubitReg</span> <span class=o>=</span> <span class=n>xacc</span><span class=o>::</span><span class=n>qalloc</span><span class=p>(</span><span class=mi>2</span><span class=p>);</span>

  <span class=c1>// Create a Program: simple Bell test
</span><span class=c1></span>  <span class=k>auto</span> <span class=n>xasmCompiler</span> <span class=o>=</span> <span class=n>xacc</span><span class=o>::</span><span class=n>getCompiler</span><span class=p>(</span><span class=s>&#34;xasm&#34;</span><span class=p>);</span>
  <span class=k>auto</span> <span class=n>ir</span> <span class=o>=</span> <span class=n>xasmCompiler</span><span class=o>-&gt;</span><span class=n>compile</span><span class=p>(</span><span class=n>R</span><span class=s>&#34;(__qpu__ void bell(qbit q, double theta) {</span>
    <span class=n>H</span><span class=p>(</span><span class=n>q</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span>
    <span class=n>CX</span><span class=p>(</span><span class=n>q</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span><span class=n>q</span><span class=p>[</span><span class=mi>1</span><span class=p>]);</span>
    <span class=n>Measure</span><span class=p>(</span><span class=n>q</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span>
    <span class=n>Measure</span><span class=p>(</span><span class=n>q</span><span class=p>[</span><span class=mi>1</span><span class=p>]);</span>
    <span class=p>})</span><span class=s>&#34;, qpu);</span>

  <span class=c1>// Request the quantum kernel representing
</span><span class=c1></span>  <span class=c1>// the above source code
</span><span class=c1></span>  <span class=k>auto</span> <span class=n>program</span> <span class=o>=</span> <span class=n>ir</span><span class=o>-&gt;</span><span class=n>getComposite</span><span class=p>(</span><span class=s>&#34;bell&#34;</span><span class=p>);</span>

  <span class=c1>// Execute!
</span><span class=c1></span>  <span class=n>qpu</span><span class=o>-&gt;</span><span class=n>execute</span><span class=p>(</span><span class=n>qubitReg</span><span class=p>,</span> <span class=n>program</span><span class=p>);</span>
  <span class=c1>// Print the result (measurement count distribution) in the buffer.
</span><span class=c1></span>  <span class=n>qubitReg</span><span class=o>-&gt;</span><span class=n>print</span><span class=p>();</span>

  <span class=c1>// Finalize the XACC Framework
</span><span class=c1></span>  <span class=n>xacc</span><span class=o>::</span><span class=n>Finalize</span><span class=p>();</span>

  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><p>It&rsquo;s worth noting that the <code>exatn-pmps</code> visitor can only simulate localized (single-qubit) noise processes and hence doesn&rsquo;t take into account correlated noise operations.</p><p>Lastly, below is the list of all available configuration options for each visitor type.</p><p>Some of the options are custom for specific simulation scenarios. Users are encouraged to submit questions on the TNQVM repository for programming supports.</p><p>For the <code>exatn</code> simulator, there are additional options that users can set during initialization:</p><table><thead><tr><th>Initialization Parameter</th><th>Parameter Description</th><th>type</th><th>default</th></tr></thead><tbody><tr><td>exatn-buffer-size-gb</td><td>ExaTN&rsquo;s host memory buffer size (in GB)</td><td>int</td><td>8 (GB)</td></tr><tr><td>exatn-contract-seq-optimizer</td><td>ExaTN&rsquo;s contraction sequence optimizer to use.</td><td>string</td><td>metis</td></tr><tr><td>calc-contract-cost-flops</td><td>Estimate the Flops and Memory requirements only (no tensor contraction)<br>If true, the following info will be added to the AcceleratorBuffer:<br>- <code>contract-flops</code>: Flops count.<br>- <code>max-node-bytes</code>: Max intermediate tensor size in memory.<br>- <code>optimizer-elapsed-time-ms</code>: optimization walltime.<br></td><td>bool</td><td>false</td></tr><tr><td>bitstring</td><td>If provided, the output amplitude/partial state vector associated with that <code>bitstring</code> will be computed.<br>The length of the input <code>bitstring</code> must match the number of qubits.<br>Non-projected bits (partial state vector) are indicated by <code>-1</code> values.<br>Returned values in the AcceleratorBuffer:<br>- <code>amplitude-real</code>/<code>amplitude-real-vec</code>: Real part of the result.<br>- <code>amplitude-imag</code>/<code>amplitude-imag-vec</code>: Imaginary part of the result.</td><td>vector<int></td><td><code>&lt;unused></code></td></tr><tr><td>contract-with-conjugate</td><td>If true, we append the conjugate of the input circuit.<br>This is used to validate internal tensor contraction.<br><code>contract-with-conjugate-result</code> key in the AcceleratorBuffer will be set to <code>true</code> if the validation is successful.</td><td>bool</td><td>false</td></tr><tr><td>mpi-communicator</td><td>The MPI communicator to initialize ExaTN runtime with.<br>If not provided, by default, ExaTN will use <code>MPI_COMM_WORLD</code>.</td><td>void*</td><td><code>&lt;unused></code></td></tr></tbody></table><p>For the <code>exatn-mps</code> simulator, there are additional options that users can set during initialization:</p><table><thead><tr><th>Initialization Parameter</th><th>Parameter Description</th><th>type</th><th>default</th></tr></thead><tbody><tr><td>svd-cutoff</td><td>SVD cut-off limit.</td><td>double</td><td>numeric_limits::min</td></tr><tr><td>max-bond-dim</td><td>Max bond dimension to keep.</td><td>int</td><td>no limit</td></tr><tr><td>mpi-communicator</td><td>The MPI communicator to initialize ExaTN runtime with.<br>If not provided, by default, ExaTN will use <code>MPI_COMM_WORLD</code>.</td><td>void*</td><td><code>&lt;unused></code></td></tr></tbody></table><p>For the <code>exatn-pmps</code> simulator, there are additional options that users can set during initialization:</p><table><thead><tr><th>Initialization Parameter</th><th>Parameter Description</th><th>type</th><th>default</th></tr></thead><tbody><tr><td>backend-json</td><td>Backend configuration JSON to estimate the noise model from.</td><td>string</td><td>None</td></tr><tr><td>backend</td><td>Name of the IBMQ backend to query the backend configuration.</td><td>string</td><td>None</td></tr></tbody></table><div class=edit-meta><br><a href=https://github.com/aide-qc/deploy//edit/master/website/content/users/tnqvm.md class=edit-page><i class="fas fa-pen-square"></i>Edit on GitHub</a></div><nav class=pagination><a class="nav nav-prev" href=/deploy/users/remote_qpu_creds/ title="Remote QPU Credentials"><i class="fas fa-arrow-left" aria-hidden=true></i>Prev - Remote QPU Credentials</a>
<a class="nav nav-next" href=/deploy/users/using_optimizer/ title="Using an Optimizer">Next - Using an Optimizer <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://aide-qc.github.io/deploy>Home</a></li><li class=has-sub-menu><a href=/deploy/background/>Background<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/deploy/background/qcor/>QCOR C++ Compiler and JIT Engine</a></li><li><a href=/deploy/background/xacc/>XACC Quantum Programming Framework</a></li><li><a href=/deploy/background/project/></a></li></ul></li><li class=has-sub-menu><a href=/deploy/developers/>Developer Guide<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/deploy/developers/implement_circuit_synthesis/>Add a New Circuit Synthesis Strategy</a></li><li><a href=/deploy/developers/implement_optimizer/>Add a New Optimizer</a></li><li><a href=/deploy/developers/implement_accelerator/>Add a New Quantum Backend</a></li><li><a href=/deploy/developers/implement_quasimo_workflow/>Add a New QuaSiMo Workflow</a></li><li><a href=/deploy/developers/implement_plugin_embedded_python/>Hybrid C++ / Python Plugins</a></li><li><a href=/deploy/developers/clang_syntax/></a></li></ul></li><li class=has-sub-menu><a href=/deploy/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/deploy/getting_started/Faq/>Frequently Asked Questions</a></li><li><a href=/deploy/getting_started/build_from_source/>Build Everything from Source</a></li></ul></li><li class="parent has-sub-menu"><a href=/deploy/users/>User Guide<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=/deploy/getting_started/Faq/>Frequently Asked Questions</a></li><li><a href=/deploy/getting_started/build_from_source/>Build Everything from Source</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>